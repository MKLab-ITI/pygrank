import unittest
import sys, inspect
import pygrank.algorithms
import pygrank.algorithms.postprocess
import pygrank.measures

"""
THIS FILE IS AUTOMATICALLY RUN BY THE pre-commit HOOK FOR git
"""


def format(doc):
    if doc is None:
        return ""
    ret = ""
    prefix = ""
    open_example = False
    for line in doc.split("\n"):
        line = line.replace("\t", "   ").strip()
        if len(line) == 0:
            continue
        if open_example and ">>>" not in line:
            ret += "\n```\n"
            open_example = False
        line_break = "\n"
        if line.startswith("Example") and ":" in line:
            line = line+"\n\n```python"
            prefix = ""
            line_break = "\n\n"
            open_example = True
        elif len(ret) == 0:
            line_break == ""
        elif len(prefix)>0 and ":" in line:
            line_break = "\n"+prefix
            line = "*"+line.replace(":",":*")
        elif len(prefix)>0 and ":" not in line:
            line_break = ""
        if line == "Attributes:" or line == "Args:" or line == "Returns:":
            prefix = " * "
            line_break = "\n\n"
        ret += line_break+line+" "
    if open_example:
        ret += "\n```\n"
    return ret


from tests.example_graph import test_graph
G = test_graph()


def is_abstract(cls, *args):
    try:
        cls(*args).rank(G)
        return False
    except:
        print(cls, "not fully implemented (is either an abstract class, or could not create a default instance and rank graph nodes)")
        return True


def extract_attributes(text):
    ret = ""
    in_attributes = False
    for line in text.split("\n"):
        if not line.startswith(" * "):
            in_attributes = False
        if in_attributes:
            ret += line+"\n"
        if line=="Attributes: " or line=="Args: ":
            in_attributes = True
    return ret


def combine_attributes(text, descriptions):
    ret = ""
    in_attributes = False
    for line in text.split("\n"):
        if not line.startswith(" * "):
            if in_attributes:
                for desc in descriptions:
                    to_add = extract_attributes(desc)
                    if to_add not in ret: # handles case of inherited constructors
                        ret += to_add
            in_attributes = False
        ret += line+"\n"
        if line == "Attributes: " or line == "Args: ":
            in_attributes = True
    if in_attributes:
        for desc in descriptions:
            to_add = extract_attributes(desc)
            if to_add not in ret: # handles case of inherited constructors
                ret += to_add
    return ret


def base_description(obj, abstract):
    extends = "<kbd>"+[cls.__name__ for cls in inspect.getmro(obj)][1]+"</kbd>"
    class_text = "\n### " + extends+" "+obj.__name__  + (
        "\n *Abstract class*\n\n" if abstract else "") + "\n" + format(obj.__doc__)[:-1]
    for name, method in inspect.getmembers(obj):
        if name == "__init__":
            class_text += " " + format(method.__doc__)
    return class_text


def generate_filter_docs():
    text = "# :scroll: List of Graph Filters"
    text += "\n*This file is automatically generated with `docgenerator.py`.*\n\nThe following filters can be imported from the package `pygrank.algorithms`.\n" \
            "Constructor details are provided, including arguments inherited from and passed to parent classes.\n" \
            "All of them can be used through the code patterns presented at the library's [documentation](documentation.md)." \
            " \n"

    base_descriptions = dict()
    abstract = dict()

    base_descriptions[pygrank.algorithms.abstract_filters.GraphFilter] = base_description(
        pygrank.algorithms.abstract_filters.GraphFilter, True)
    abstract[pygrank.algorithms.abstract_filters.GraphFilter] = True
    for name, obj in inspect.getmembers(sys.modules["pygrank.algorithms"]):
        if inspect.isclass(obj) and issubclass(obj, pygrank.algorithms.abstract_filters.GraphFilter):
            abstract[obj] = is_abstract(obj)
            base_descriptions[obj] = base_description(obj, abstract[obj])

    count = 0
    for abstr in base_descriptions:
        if abstract[abstr]:
            #text += "\n**"+abstr.__name__+"**\n"
            for obj in base_descriptions:
                if not abstract[obj] and abstr == list(inspect.getmro(obj))[1]:
                    count += 1
                    text += str(count)+". ["+obj.__name__+"](#"+"kbd"+[cls.__name__ for cls in inspect.getmro(obj)][1].lower()+"kbd-"+obj.__name__.lower()+")\n"

    for abstr in base_descriptions:
        if abstract[abstr]:
            for obj in base_descriptions:
                if not abstract[obj] and abstr == list(inspect.getmro(obj))[1]:
                    text += combine_attributes(base_descriptions[obj], [base_descriptions.get(cls,"") for cls in inspect.getmro(obj)][1:])

    with open("tutorials/graph_filters.md", "w") as file:
        file.write(text)


def generate_postprocessor_docs():
    text = "# :scroll: List of Postprocessors"
    text += "\n*This file is automatically generated with `docgenerator.py`.*\n\nThe following postprocessors can be imported from the package " \
            "`pygrank.algorithms.postprocess`.\n" \
            "Constructor details are provided, including arguments inherited from and passed to parent classes.\n" \
            "All of them can be used through the code patterns presented at the library's [documentation](documentation.md). " \
            " \n"

    base_descriptions = dict()
    abstract = dict()

    for name, obj in inspect.getmembers(sys.modules["pygrank.algorithms.postprocess"]):
        if inspect.isclass(obj) and issubclass(obj, pygrank.algorithms.postprocess.Postprocessor):
            abstract[obj] = False#is_abstract(obj, pygrank.algorithms.PageRank()) TODO - fix this
            base_descriptions[obj] = base_description(obj, abstract[obj])
    base_descriptions[pygrank.algorithms.postprocess.Postprocessor] = base_description(
        pygrank.algorithms.postprocess.Postprocessor, True)
    abstract[pygrank.algorithms.postprocess.Postprocessor] = True

    count = 0
    for obj in base_descriptions:
        if not abstract[obj]:
            count += 1
            text += str(count)+". ["+obj.__name__+"](#"+"kbd"+[cls.__name__ for cls in inspect.getmro(obj)][1].lower()+"kbd-"+obj.__name__.lower()+")\n"

    for abstr in base_descriptions:
        if abstract[abstr]:
            for obj in base_descriptions:
                if not abstract[obj] and abstr in inspect.getmro(obj):
                    text += combine_attributes(base_descriptions[obj], [base_descriptions.get(cls,"") for cls in inspect.getmro(obj)][1:])

    with open("tutorials/postprocessors.md", "w") as file:
        file.write(text)


def generate_metric_docs():
    text = "# :scroll: List of Measures"
    text += "\n*This file is automatically generated with `docgenerator.py`.*\n\nThe following measures can be imported from the package " \
            "`pygrank.measures`.\n" \
            "Constructor details are provided, including arguments inherited from and passed to parent classes.\n" \
            "All of them can be used through the code patterns presented at the library's [documentation](documentation.md). " \
            " \n"

    base_descriptions = dict()
    abstract = dict()

    for name, obj in inspect.getmembers(sys.modules["pygrank.measures"]):
        if inspect.isclass(obj) and issubclass(obj, pygrank.measures.Measure):
            abstract[obj] = False#is_abstract(obj, pygrank.algorithms.PageRank()) TODO - fix this
            base_descriptions[obj] = base_description(obj, abstract[obj])

    base_descriptions[pygrank.measures.Supervised] = base_description(pygrank.measures.Supervised, True)
    abstract[pygrank.measures.Supervised] = True
    base_descriptions[pygrank.measures.Measure] = base_description(pygrank.measures.Measure, True)
    abstract[pygrank.measures.Measure] = True

    count = 0
    for abstr in base_descriptions:
        if abstract[abstr]:
            for obj in base_descriptions:
                if not abstract[obj] and abstr == list(inspect.getmro(obj))[1]:
                    count += 1
                    text += str(count)+". ["+obj.__name__+"](#"+"kbd"+[cls.__name__ for cls in inspect.getmro(obj)][1].lower()+"kbd-"+obj.__name__.lower()+")\n"

    for abstr in base_descriptions:
        if abstract[abstr]:
            for obj in base_descriptions:
                if not abstract[obj] and abstr == list(inspect.getmro(obj))[1]:
                    text += combine_attributes(base_descriptions[obj], [base_descriptions.get(cls,"") for cls in inspect.getmro(obj)][1:])

    with open("tutorials/measures.md", "w") as file:
        file.write(text)


def generate_tuning_docs():
    text = "# :scroll: List of Tuners"
    text += "\n*This file is automatically generated with `docgenerator.py`.*\n\nThe following tuning mechanisms can be imported from the package " \
            "`pygrank.algorithms.autotune`.\n" \
            "Constructor details are provided, including arguments inherited from and passed to parent classes.\n" \
            "All of them can be used through the code patterns presented at the library's [documentation](documentation.md). " \
            " \n"

    base_descriptions = dict()
    abstract = dict()

    for name, obj in inspect.getmembers(sys.modules["pygrank.algorithms.autotune"]):
        if inspect.isclass(obj) and issubclass(obj, pygrank.algorithms.autotune.Tuner):
            abstract[obj] = False#is_abstract(obj, pygrank.algorithms.PageRank()) TODO - fix this
            base_descriptions[obj] = base_description(obj, abstract[obj])

    base_descriptions[pygrank.algorithms.autotune.Tuner] = base_description(pygrank.algorithms.autotune.Tuner, True)
    abstract[pygrank.algorithms.autotune.Tuner] = True

    count = 0
    for abstr in base_descriptions:
        if abstract[abstr]:
            for obj in base_descriptions:
                if not abstract[obj] and abstr == list(inspect.getmro(obj))[1]:
                    count += 1
                    text += str(count)+". ["+obj.__name__+"](#"+"kbd"+[cls.__name__ for cls in inspect.getmro(obj)][1].lower()+"kbd-"+obj.__name__.lower()+")\n"

    for abstr in base_descriptions:
        if abstract[abstr]:
            for obj in base_descriptions:
                if not abstract[obj] and abstr == list(inspect.getmro(obj))[1]:
                    text += combine_attributes(base_descriptions[obj], [base_descriptions.get(cls,"") for cls in inspect.getmro(obj)][1:])

    with open("tutorials/tuners.md", "w") as file:
        file.write(text)


if __name__ == '__main__':
    generate_filter_docs()
    generate_postprocessor_docs()
    generate_metric_docs()
    generate_tuning_docs()