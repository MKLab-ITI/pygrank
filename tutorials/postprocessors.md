# :scroll: List of Postprocessors
*This file is automatically generated with `docgenerator.py`.*

The following postprocessors can be imported from the package `pygrank.algorithms.postprocess`.
Constructor details are provided, including arguments inherited from and passed to parent classes.
All of them can be used through the code patterns presented at the library's [documentation](documentation.md).  

### BoostedSeedOversampling 

Iteratively performs seed oversampling and combines found ranks by weighting them with a Boosting scheme. 
Initializes the class with a base ranker and the boosting scheme's parameters. 

Attributes: 
 * *ranker:* The base ranker instance. 
 * *objective:* Optional. Can be either "partial" (default) or "naive". 
 * *oversample_from_iteration:* Optional. Can be either "previous" (default) to oversample the ranks of the previous iteration or "original" to always ovesample the given personalization. 
 * *weight_convergence:* Optional.  A ConvergenceManager that helps determine whether the weights placed on boosting iterations have converged. If None (default), initialized with ConvergenceManager(error_type="small_value", tol=0.001, max_iters=100) 

Example:

```python 
>>> from pygrank.algorithms.adhoc import PageRank 
>>> from pygrank.algorithms.oversampling import BoostedSeedOversampling 
>>> G, seed_nodes = ... 
>>> algorithm = BoostedSeedOversampling(PageRank(alpha=0.99)) 
>>> ranks = algorithm.rank(G, personalization={1 for v in seed_nodes}) 
```


### FairPostprocessor 

Adjusts node scores so that the sum of sensitive nodes is closer to the sum of non-sensitive ones. 
Initializes the fairness-aware postprocessor. 

Args: 
 * *ranker:* The base ranking algorithm. 
 * *method:* The method with which to adjust weights. If "O" (default) an optimal gradual adjustment is performed. If "B" node scores are weighted according to whether the nodes are sensitive, so that the sum of sensitive node scores becomes equal to the sum of non-sensitive node scores. If "reweight" the graph is pre-processed so that, when possible, walks are equally probable to visit sensitive or non-sensitive nodes at non-restarting iterations. 

### FairWeights 

Weights node scores based on whether they are sensitive, so that the sum of sensitive 
and non-sensitive scores are equal. 

### Normalize 

Normalizes ranks by dividing with their maximal value. 
Initializes the class with a base ranker instance. Args are automatically filled in and 
re-ordered if at least one is provided. 

Args: 
 * *ranker:* The base ranker instance. A Tautology() ranker is created if None (default) was specified. 
 * *method:* Divide ranks either by their "max" (default) or by their "sum" or make the lie in the "range" [0,1] by subtracting their mean before diving by their max. 

Example:

```python 
>>> from pygrank.algorithms.postprocess import Normalize 
>>> graph, personalization, algorithm = ... 
>>> algorithm = Normalize(0.5, algorithm) # sets ranks >= 0.5 to 1 and lower ones to 0 
>>> ranks = algorithm.rank(graph, personalization) 
```


Example (same outcome, simpler one-liner):

```python 
>>> from pygrank.algorithms.postprocess import Normalize 
>>> graph, personalization, algorithm = ... 
>>> ranks = Normalize(0.5).transform(algorithm.rank(graph, personalization)) 
```


### Ordinals 

Converts ranking outcome to ordinal numbers. 
The highest rank is set to 1, the second highest to 2, etc. 
Initializes the class with a base ranker instance. 

Args: 
 * *ranker:* Optional. The base ranker instance. A Tautology() ranker is created if None (default) was specified. 

### SeedOversampling 

Performs seed oversampling on a base ranker to improve the quality of predicted seeds. 
Initializes the class with a base ranker. 

Attributes: 
 * *ranker:* The base ranker instance. 
 * *method:* Optional. Can be "safe" (default) to oversample based on the ranking scores of a preliminary base ranker run or "neighbors" to oversample the neighbors of personalization nodes. 

Example:

```python 
>>> from pygrank.algorithms.postprocess import oversampling 
>>> from pygrank.algorithms import adhoc 
>>> G, seed_nodes = ... 
>>> algorithm = oversampling.SeedOversampling(adhoc.PageRank(alpha=0.99)) 
>>> ranks = algorithm.rank(G, personalization={1 for v in seed_nodes}) 
```


### Sweep 

Applies a sweep procedure that divides personalized node ranks by corresponding non-personalized ones. 
Initializes the sweep procedure. 

Args: 
 * *ranker:* The base ranker instance. 
 * *uniform_ranker:* Optional. The ranker instance used to perform non-personalized ranking. If None (default) the base ranker is used. 

### Tautology 

Returns ranks as-are. 
Can be used as a baseline against which to compare other postprocessors. 

### Threshold 

Converts ranking outcome to binary values based on a threshold value. 
Initializes the Threshold postprocessing scheme. Args are automatically filled in and 
re-ordered if at least one is provided. 

Args: 
 * *ranker:* Optional. The base ranker instance. A Tautology() ranker is created if None (default) was specified. 
 * *threshold:* Optional. The minimum numeric value required to output rank 1 instead of 0. If "gap" (default) then its value is automatically determined based on the maximal percentage increase between consecutive ranks. 

Example:

```python 
>>> from pygrank.algorithms.postprocess import Threshold 
>>> graph, personalization, algorithm = ... 
>>> algorithm = Threshold(algorithm, 0.5) # sets ranks >= 0.5 to 1 and lower ones to 0 
>>> ranks = algorithm.rank(graph, personalization) 
```


Example (same outcome):

```python 
>>> from pygrank.algorithms.postprocess import Threshold 
>>> graph, personalization, algorithm = ... 
>>> ranks = Threshold(0.5).transform(algorithm.rank(graph, personalization)) 
```


### Transformer 

Applies an element-by-element transformation on a graph signal based on a given expression. 
Initializes the class with a base ranker instance. Args are automatically filled in and 
re-ordered if at least one is provided. 

Args: 
 * *ranker:* Optional. The base ranker instance. A Tautology() ranker is created if None (default) was specified. 
 * *expr:* Optional. A lambda expression to apply on each element. The transformer will automatically try to apply it on the backend array representation of the graph signal first, so prefer use of backend functions for faster computations. For example, backend.exp (default) should be prefered instead of math.exp, because the former can directly parse a numpy array. 

Example:

```python 
>>> from pygrank.algorithms.postprocess import Normalize, Transformer 
>>> from pygrank import backend 
>>> graph, personalization, algorithm = ... 
>>> r1 = Normalize(algorithm, "sum").rank(graph, personalization) 
>>> r2 = Transformer(algorithm, lambda x: x/backend.sum(x)).rank(graph, personalization) 
>>> print(sum(abs(r1[v]-r2[v]) for v in graph)) 
```

0 
